```html
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Menton Web Runner</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    textarea { width: 100%; height: 340px; box-sizing: border-box; }
    pre {
      background:#111; color:#eee; padding:12px; white-space:pre-wrap;
      border-radius:10px; min-height: 140px; box-sizing: border-box;
    }
    button { padding: 10px 14px; cursor: pointer; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin: 10px 0; }
    .muted { opacity:.75; }
    .small { font-size: 12px; }
  </style>
</head>
<body>

<h1>Menton Web Runner</h1>

<div class="row">
  <button id="runBtn">실행</button>
  <span id="status" class="muted"></span>
  <span class="muted small">Pyodide 로딩이 처음엔 조금 걸릴 수 있음</span>
</div>

<textarea id="code"></textarea>

<h3>출력</h3>
<pre id="out"></pre>

<!-- mentonlang.py 전체(주석 기능 + 업데이트된 웃음 숫자 규칙 포함) -->
<script id="mentonlang-py" type="text/plain">
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

# ----------------------------
# Config / Tokens
# ----------------------------
NEWLINE_TOKEN = "으이?"

REG_BASE = ["멘", "빵", "깨", "털", "두", "덜", "애"]  # order defines register ordering
REGTOK_GLUE = "가"

TOK_SET = "하요하요"
TOK_RESET = "바요바요"

TOK_ADD = "누이 좋고"
TOK_SUB = "매부 좋고"
TOK_MUL = "아주 좋고"

TOK_IF = "건방진"
TOK_WHILE = "좋다좋다"
TOK_END = "쉐끼마"
TOK_ELSE = "정신이 나갔어 정신이"

CMP_GT = "응나멘똔"
CMP_LT = "응너도혁"

TOK_PRINT_START = "와타시는"
TOK_PRINT_NUM_END = "이에요"
TOK_PRINT_CHAR_END = "한다는 것이야"

# Laugh-number tokens
NEG_LAUGH = "뭐꼬"
T_I = "훠"
T_X = "훳"
T_C = "허"
T_M = "헛"
T_FIVE_PREFIX = "훠러"
T_GROUP_ZERO = "찢"


# ----------------------------
# Helpers: comment stripping
# ----------------------------
def clean_line(raw: str) -> str:
    """
    Comment rule:
      - Anything after '#' is ignored.
      - Leading/trailing whitespace trimmed.
    """
    return raw.split("#", 1)[0].strip()


# ----------------------------
# Helpers: register parsing
# ----------------------------
def build_register_set() -> Tuple[Dict[str, int], Dict[int, str]]:
    """
    49 registers: A가B가 where A,B in REG_BASE (7x7 total)
    """
    reg_to_idx: Dict[str, int] = {}
    idx_to_reg: Dict[int, str] = {}
    idx = 0
    for a in REG_BASE:
        for b in REG_BASE:
            token = f"{a}{REGTOK_GLUE}{b}{REGTOK_GLUE}"
            reg_to_idx[token] = idx
            idx_to_reg[idx] = token
            idx += 1
    return reg_to_idx, idx_to_reg


REG_TO_IDX, IDX_TO_REG = build_register_set()


def is_register_token(line: str) -> bool:
    return line.strip() in REG_TO_IDX


# ----------------------------
# Helpers: number parsing
# ----------------------------
def parse_arabic_int(s: str) -> Optional[int]:
    s = s.strip()
    if not s:
        return None
    try:
        return int(s)
    except ValueError:
        return None


def parse_laugh_number(s: str) -> Optional[int]:
    """
    Updated laugh-number format (supports negative with '뭐꼬' prefix).

    Spec:
      (1) Place tokens cycle every 4 decimal digits:
            1s : 훠
            10s: 훳
            100s: 허
            1000s: 헛
          Above 1000s, repeat the same 4 in order:
            10,000s uses 훠 again, 100,000s uses 훳, ...

      (2) Digit (0..9) encoding per place:
            0   : omitted
            1-5 : repeat the place token that many times (5 is 5 repeats)
            6-9 : "훠러" + repeat the place token (digit-5) times

      (3) Multi-digit numbers are written from larger place -> smaller place.

      (4) Special group-zero marker:
            If an entire 4-digit group is 0000, write a single token "찢".

    Notes:
      - This parser is "positional" (digit stream), not additive.
      - Between explicit place segments, skipping up to 3 places as 0 is allowed.
      - Skipping a whole 4-digit group must use "찢".
    """
    raw = s.strip()
    if not raw:
        return None

    neg = False
    if raw.startswith(NEG_LAUGH):
        neg = True
        raw = raw[len(NEG_LAUGH):].strip()
        if not raw:
            return None

    # Tokenize into items:
    #   - ("ZZ", 0) for "찢" (a whole 4-digit zero group)
    #   - (place_token, digit 1..9)
    place_tokens = {T_I, T_X, T_C, T_M}

    items: List[Tuple[str, int]] = []
    i = 0
    while i < len(raw):
        ch = raw[i]

        if ch == T_GROUP_ZERO:
            items.append(("ZZ", 0))
            i += 1
            continue

        has_five = raw.startswith(T_FIVE_PREFIX, i)
        if has_five:
            i += len(T_FIVE_PREFIX)
            if i >= len(raw):
                return None

        place = raw[i]
        if place not in place_tokens:
            return None

        cnt = 0
        while i < len(raw) and raw[i] == place:
            cnt += 1
            i += 1

        if has_five:
            if not (1 <= cnt <= 4):
                return None
            digit = 5 + cnt
        else:
            if not (1 <= cnt <= 5):
                return None
            digit = cnt

        items.append((place, digit))

    if not items:
        return None

    # Descending cycle: 헛 -> 허 -> 훳 -> 훠 -> 헛 -> ...
    next_place = {T_M: T_C, T_C: T_X, T_X: T_I, T_I: T_M}

    # First non-"찢" defines starting (highest) place
    start_place: Optional[str] = None
    for p, _d in items:
        if p != "ZZ":
            start_place = p
            break
    if start_place is None:
        # Only "찢" tokens is ambiguous; treat as invalid
        return None

    value = 0
    expected = start_place

    for p, d in items:
        if p == "ZZ":
            value *= 10000
            continue

        # Allow skipping up to 3 places as zeros to match expected->p
        skips = 0
        cur = expected
        while cur != p and skips < 4:
            cur = next_place[cur]
            skips += 1
        if cur != p:
            return None
        if skips >= 4:
            # whole groups must be "찢"
            return None

        for _ in range(skips):
            value *= 10
            expected = next_place[expected]

        value = value * 10 + d
        expected = next_place[expected]

    return -value if neg else value


def parse_number_or_none(s: str) -> Optional[int]:
    v = parse_arabic_int(s)
    if v is not None:
        return v
    return parse_laugh_number(s)


# ----------------------------
# Program indexing (blocks)
# ----------------------------
@dataclass
class IfMeta:
    else_ip: Optional[int]
    end_ip: int


@dataclass
class WhileMeta:
    start_ip: int
    end_ip: int


@dataclass
class ProgramIndex:
    if_map: Dict[int, IfMeta]
    while_map: Dict[int, WhileMeta]


def index_blocks(lines: List[str]) -> ProgramIndex:
    """
    Build jump tables for if/else/end and while/end.
    Comments are ignored.
    """
    if_map: Dict[int, IfMeta] = {}
    while_map: Dict[int, WhileMeta] = {}

    stack: List[Tuple[str, int, Optional[int]]] = []  # (kind, start_ip, else_ip_if_any)

    for ip, raw in enumerate(lines):
        line = clean_line(raw)
        if not line:
            continue

        if line.startswith(TOK_IF):
            stack.append(("if", ip, None))
        elif line == TOK_ELSE:
            if not stack or stack[-1][0] != "if":
                raise SyntaxError(f"ELSE without IF at line {ip+1}")
            kind, start_ip, _ = stack.pop()
            stack.append((kind, start_ip, ip))
        elif line.startswith(TOK_WHILE):
            stack.append(("while", ip, None))
        elif line == TOK_END:
            if not stack:
                raise SyntaxError(f"END without block at line {ip+1}")
            kind, start_ip, else_ip = stack.pop()
            if kind == "if":
                if_map[start_ip] = IfMeta(else_ip=else_ip, end_ip=ip)
            elif kind == "while":
                while_map[start_ip] = WhileMeta(start_ip=start_ip, end_ip=ip)
            else:
                raise SyntaxError(f"Unknown block kind at line {ip+1}")

    if stack:
        kind, start_ip, _ = stack[-1]
        raise SyntaxError(f"Unclosed block '{kind}' starting at line {start_ip+1}")

    return ProgramIndex(if_map=if_map, while_map=while_map)


# ----------------------------
# Condition parsing/evaluation
# ----------------------------
def parse_condition(line: str) -> Tuple[int, str]:
    parts = line.strip().split()
    if len(parts) < 2:
        raise SyntaxError(f"Missing number in condition: '{line}'")

    n_str = parts[1]
    n = parse_number_or_none(n_str)
    if n is None:
        raise SyntaxError(f"Invalid number in condition: '{n_str}'")

    op = "=="
    if len(parts) >= 3:
        if parts[2] == CMP_GT:
            op = ">"
        elif parts[2] == CMP_LT:
            op = "<"
        else:
            raise SyntaxError(f"Unknown comparator '{parts[2]}' in: '{line}'")
    return n, op


def eval_condition(cur: int, n: int, op: str) -> bool:
    if op == "==":
        return cur == n
    if op == ">":
        return cur > n
    if op == "<":
        return cur < n
    raise RuntimeError(f"Unknown op: {op}")


# ----------------------------
# Interpreter
# ----------------------------
class Interpreter:
    def __init__(self, lines: List[str]):
        self.lines = lines
        self.index = index_blocks(lines)

        self.regs: List[int] = [0] * 49
        self.cur_idx: int = REG_TO_IDX["멘가멘가"]

        self.output_chunks: List[str] = []

    def cur_value(self) -> int:
        return self.regs[self.cur_idx]

    def set_cur_value(self, v: int) -> None:
        self.regs[self.cur_idx] = v

    def run(self) -> str:
        ip = 0
        while ip < len(self.lines):
            raw = self.lines[ip]
            line = clean_line(raw)

            if not line:
                ip += 1
                continue

            if is_register_token(line):
                self.cur_idx = REG_TO_IDX[line]
                ip += 1
                continue

            if line == TOK_PRINT_START:
                ip = self._exec_output_block(ip)
                continue

            if line.startswith(TOK_IF):
                n, op = parse_condition(line)
                meta = self.index.if_map.get(ip)
                if meta is None:
                    raise RuntimeError(f"Missing IF meta at line {ip+1}")

                cond = eval_condition(self.cur_value(), n, op)
                if cond:
                    ip += 1
                else:
                    if meta.else_ip is not None:
                        ip = meta.else_ip + 1
                    else:
                        ip = meta.end_ip + 1
                continue

            if line == TOK_ELSE:
                owner_if = None
                for _if_ip, meta in self.index.if_map.items():
                    if meta.else_ip == ip:
                        owner_if = meta
                        break
                if owner_if is None:
                    raise RuntimeError(f"ELSE meta not found at line {ip+1}")
                ip = owner_if.end_ip + 1
                continue

            if line.startswith(TOK_WHILE):
                n, op = parse_condition(line)
                meta = self.index.while_map.get(ip)
                if meta is None:
                    raise RuntimeError(f"Missing WHILE meta at line {ip+1}")

                cond = eval_condition(self.cur_value(), n, op)
                if cond:
                    ip += 1
                else:
                    ip = meta.end_ip + 1
                continue

            if line == TOK_END:
                owner_while_start = None
                for wstart, wmeta in self.index.while_map.items():
                    if wmeta.end_ip == ip:
                        owner_while_start = wstart
                        break
                if owner_while_start is not None:
                    ip = owner_while_start
                else:
                    ip += 1
                continue

            if line.startswith(TOK_SET):
                rest = line[len(TOK_SET):].strip()
                if rest == "":
                    self.set_cur_value(0)
                else:
                    v = parse_number_or_none(rest)
                    if v is None:
                        raise SyntaxError(f"Invalid number for SET at line {ip+1}: '{rest}'")
                    self.set_cur_value(v)
                ip += 1
                continue

            if line == TOK_RESET:
                self.set_cur_value(0)
                ip += 1
                continue

            if line.startswith(TOK_ADD):
                rest = line[len(TOK_ADD):].strip()
                delta = 1
                if rest:
                    v = parse_number_or_none(rest)
                    if v is None:
                        raise SyntaxError(f"Invalid number for ADD at line {ip+1}: '{rest}'")
                    delta = v
                self.set_cur_value(self.cur_value() + delta)
                ip += 1
                continue

            if line.startswith(TOK_SUB):
                rest = line[len(TOK_SUB):].strip()
                delta = 1
                if rest:
                    v = parse_number_or_none(rest)
                    if v is None:
                        raise SyntaxError(f"Invalid number for SUB at line {ip+1}: '{rest}'")
                    delta = v
                self.set_cur_value(self.cur_value() - delta)
                ip += 1
                continue

            if line.startswith(TOK_MUL):
                rest = line[len(TOK_MUL):].strip()
                if not rest:
                    raise SyntaxError(f"MUL missing operand at line {ip+1}")
                if rest not in REG_TO_IDX:
                    raise SyntaxError(f"MUL operand must be a register token at line {ip+1}: '{rest}'")
                rhs = self.regs[REG_TO_IDX[rest]]
                self.set_cur_value(self.cur_value() * rhs)
                ip += 1
                continue

            raise SyntaxError(f"Unknown statement at line {ip+1}: '{line}'")

        return "".join(self.output_chunks)

    def _exec_output_block(self, start_ip: int) -> int:
        ip = start_ip + 1
        if ip >= len(self.lines):
            raise SyntaxError(f"Unterminated output block starting at line {start_ip+1}")

        content: List[str] = []
        terminator: Optional[str] = None

        while ip < len(self.lines):
            line = clean_line(self.lines[ip])
            if line == "":
                ip += 1
                continue
            if line == TOK_PRINT_NUM_END or line == TOK_PRINT_CHAR_END:
                terminator = line
                break
            content.append(line)
            ip += 1

        if terminator is None:
            raise SyntaxError(f"Unterminated output block starting at line {start_ip+1}")

        if terminator == TOK_PRINT_NUM_END:
            for item in content:
                if item in REG_TO_IDX:
                    v = self.regs[REG_TO_IDX[item]]
                else:
                    v = parse_number_or_none(item)
                    if v is None:
                        raise SyntaxError(
                            f"Invalid number/register in numeric output near line {ip+1}: '{item}'"
                        )
                self.output_chunks.append(str(v))
        else:
            for item in content:
                v = parse_number_or_none(item)
                if v is None:
                    raise SyntaxError(
                        f"Invalid number in ASCII output (register not allowed) near line {ip+1}: '{item}'"
                    )
                self.output_chunks.append(chr(v % 256))

        return ip + 1


# ----------------------------
# I/O
# ----------------------------
def preprocess(src: str) -> str:
    return src.replace(NEWLINE_TOKEN, "\n")


def main(argv: List[str]) -> int:
    if len(argv) != 2:
        print("Usage: python mentonlang.py <program.txt>", file=sys.stderr)
        return 2

    path = argv[1]
    with open(path, "r", encoding="utf-8") as f:
        src = f.read()

    src = preprocess(src)
    lines = src.splitlines()

    interp = Interpreter(lines)
    out = interp.run()
    sys.stdout.write(out)
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
</script>

<script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>
<script>
  const codeEl = document.getElementById("code");
  const outEl = document.getElementById("out");
  const statusEl = document.getElementById("status");

  // 기본 예제: 주석 포함 + 아랍숫자 (확실히 동작 확인용)
  codeEl.value =
`# Hello, World! (웃음 숫자)

와타시는
훳훳훳훳훳훳훳훠훠        # 72  H
허훠훳훳훳훳훳훳훳훳훳     # 101 e
허훳훳훳훳훳훳훳훠훠훠     # 108 l
허훳훳훳훳훳훳훳훠훠훠     # 108 l
허훳훳훳훳훳훳훳훳훠        # 111 o
훳훳훳훳훠훠훠훠           # 44  ,
훳훳훳훠훠                # 32  space
훳훳훳훳훳훳훳훠훠훠        # 87  W
허훳훳훳훳훳훳훳훳훠        # 111 o
허훳훳훳훳훳훳훳훳훳훠훠    # 114 r
허훳훳훳훳훳훳훳훠훠훠     # 108 l
허훳훳훳훳훳              # 100 d
훳훳훳훠훠훠              # 33  !
훳                         # 10  newline
한다는 것이야
`;

  const pyodideReady = (async () => {
    statusEl.textContent = "Pyodide 로딩 중...";
    const pyodide = await loadPyodide();
    statusEl.textContent = "준비됨";
    return pyodide;
  })();

  function stripMain(pySrc) {
    // 웹에서는 CLI 실행부가 필요 없으니 제거
    return pySrc.replace(/if __name__\s*==\s*["']__main__["']\s*:[\s\S]*$/m, "");
  }

  async function ensureInterpreterLoaded(pyodide) {
    if (window.__menton_loaded) return;
    let src = document.getElementById("mentonlang-py").textContent;
    src = stripMain(src);
    pyodide.runPython(src);
    window.__menton_loaded = true;
  }

  document.getElementById("runBtn").onclick = async () => {
    outEl.textContent = "";
    statusEl.textContent = "실행 중...";
    try {
      const pyodide = await pyodideReady;
      await ensureInterpreterLoaded(pyodide);

      const userCode = codeEl.value;

      const result = pyodide.runPython(`
src = preprocess(${JSON.stringify(userCode)})
lines = src.splitlines()
Interpreter(lines).run()
      `);

      outEl.textContent = result ?? "";
      statusEl.textContent = "완료";
    } catch (e) {
      statusEl.textContent = "에러";
      outEl.textContent = String(e);
      console.error(e);
    }
  };
</script>

</body>
</html>
```


